diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/allcodecs.c FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/allcodecs.c
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/allcodecs.c	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/allcodecs.c	2016-02-09 20:23:36.764950678 +0100
@@ -113,6 +113,7 @@
     REGISTER_HWACCEL(WMV3_DXVA2,        wmv3_dxva2);
     REGISTER_HWACCEL(WMV3_VAAPI,        wmv3_vaapi);
     REGISTER_HWACCEL(WMV3_VDPAU,        wmv3_vdpau);
+    REGISTER_HWACCEL(MSMPEG4V3_VDPAU,   msmpeg4v3_vdpau);
 
     /* video codecs */
     REGISTER_ENCODER(A64MULTI,          a64multi);
@@ -243,8 +244,10 @@
     REGISTER_DECODER(MSA1,              msa1);
     REGISTER_DECODER(MSMPEG4_CRYSTALHD, msmpeg4_crystalhd);
     REGISTER_DECODER(MSMPEG4V1,         msmpeg4v1);
+    REGISTER_DECODER(MSMPEG4V1_VDPAU,   msmpeg4v1_vdpau);
     REGISTER_ENCDEC (MSMPEG4V2,         msmpeg4v2);
     REGISTER_ENCDEC (MSMPEG4V3,         msmpeg4v3);
+    REGISTER_DECODER(MSMPEG4V3_VDPAU,   msmpeg4v3_vdpau);
     REGISTER_DECODER(MSRLE,             msrle);
     REGISTER_DECODER(MSS1,              mss1);
     REGISTER_DECODER(MSS2,              mss2);
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/avcodec.h FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/avcodec.h
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/avcodec.h	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/avcodec.h	2016-02-09 20:23:03.572670785 +0100
@@ -122,6 +122,7 @@
     AV_CODEC_ID_MSMPEG4V1,
     AV_CODEC_ID_MSMPEG4V2,
     AV_CODEC_ID_MSMPEG4V3,
+    AV_CODEC_ID_MSMPEG4V4,
     AV_CODEC_ID_WMV1,
     AV_CODEC_ID_WMV2,
     AV_CODEC_ID_H263P,
@@ -1760,9 +1761,11 @@
                             const AVFrame *src, int offset[AV_NUM_DATA_POINTERS],
                             int y, int type, int height);
 
+    int (*set_video_header)(struct AVCodecContext *avctx, const uint32_t id);
+
     /**
      * callback to negotiate the pixelFormat
-     * @param fmt is the list of formats which are supported by the codec,
+     * @param fmt is the list of formats which are supported by the codec,F
      * it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.
      * The first is always the native one.
      * @note The callback may be called again immediately if initialization for
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/h263dec.c FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/h263dec.c
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/h263dec.c	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/h263dec.c	2016-02-09 20:24:55.705770616 +0100
@@ -161,7 +161,11 @@
 {
     int pos = (get_bits_count(&s->gb) + 7) >> 3;
 
-    if (s->divx_packed || s->avctx->hwaccel) {
+    if(s->divx_packed || (s->avctx->hwaccel &&
+         !(s->codec_id == AV_CODEC_ID_MSMPEG4V1 || 
+           s->codec_id == AV_CODEC_ID_MSMPEG4V2 ||
+           s->codec_id == AV_CODEC_ID_MSMPEG4V3 ||
+           s->codec_id == AV_CODEC_ID_MSMPEG4V4))) {
         /* We would have to scan through the whole buf to handle the weird
          * reordering ... */
         return buf_size;
@@ -197,7 +201,7 @@
 
     ff_set_qscale(s, s->qscale);
 
-    if (s->avctx->hwaccel) {
+    if (s->avctx->hwaccel /* && !s->msmpeg4_version */) {
         const uint8_t *start = s->gb.buffer + get_bits_count(&s->gb) / 8;
         ret = s->avctx->hwaccel->decode_slice(s->avctx, start, s->gb.buffer_end - start);
         // ensure we exit decode loop
@@ -604,7 +608,8 @@
         ff_thread_finish_setup(avctx);
 
 #if FF_API_CAP_VDPAU
-    if (CONFIG_MPEG4_VDPAU_DECODER && (s->avctx->codec->capabilities & AV_CODEC_CAP_HWACCEL_VDPAU)) {
+    if ((CONFIG_MPEG4_VDPAU_DECODER || CONFIG_MSMPEG4V3_VDPAU_DECODER) && 
+          (s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)) {
         ff_vdpau_mpeg4_decode_picture(avctx->priv_data, s->gb.buffer, s->gb.buffer_end - s->gb.buffer);
         goto frame_end;
     }
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/Makefile FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/Makefile
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/Makefile	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/Makefile	2016-02-09 20:24:14.363754911 +0100
@@ -706,6 +706,7 @@
 
 OBJS-$(CONFIG_H263_VAAPI_HWACCEL)         += vaapi_mpeg4.o
 OBJS-$(CONFIG_H263_VDPAU_HWACCEL)         += vdpau_mpeg4.o
+OBJS-$(CONFIG_MSMPEG4V3_VDPAU_HWACCEL)    += vdpau_msmpeg4.o
 OBJS-$(CONFIG_H263_VIDEOTOOLBOX_HWACCEL)  += videotoolbox.o
 OBJS-$(CONFIG_H264_D3D11VA_HWACCEL)       += dxva2_h264.o
 OBJS-$(CONFIG_H264_DXVA2_HWACCEL)         += dxva2_h264.o
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/mpeg12dec.c FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/mpeg12dec.c
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/mpeg12dec.c	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/mpeg12dec.c	2016-02-09 20:23:03.576004012 +0100
@@ -1187,7 +1187,7 @@
     AV_PIX_FMT_XVMC,
 #endif
 #if CONFIG_MPEG1_VDPAU_DECODER && FF_API_VDPAU
-    AV_PIX_FMT_VDPAU_MPEG1,
+//    AV_PIX_FMT_VDPAU_MPEG1,
 #endif
 #if CONFIG_MPEG1_VDPAU_HWACCEL
     AV_PIX_FMT_VDPAU,
@@ -1201,7 +1201,7 @@
     AV_PIX_FMT_XVMC,
 #endif
 #if CONFIG_MPEG_VDPAU_DECODER && FF_API_VDPAU
-    AV_PIX_FMT_VDPAU_MPEG2,
+//    AV_PIX_FMT_VDPAU_MPEG2,
 #endif
 #if CONFIG_MPEG2_VDPAU_HWACCEL
     AV_PIX_FMT_VDPAU,
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/mpeg4videodec.c FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/mpeg4videodec.c
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/mpeg4videodec.c	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/mpeg4videodec.c	2016-02-09 20:23:03.576004012 +0100
@@ -34,6 +34,7 @@
 #include "h263.h"
 #include "thread.h"
 #include "xvididct.h"
+#include "vdpau.h"
 
 /* The defines below define the number of bits that are read at once for
  * reading vlc values. Changing these may improve speed and data cache needs
@@ -2599,6 +2600,9 @@
         if (startcode >= 0x120 && startcode <= 0x12F) {
             if ((ret = decode_vol_header(ctx, gb)) < 0)
                 return ret;
+            if(s->avctx->set_video_header) {
+               s->avctx->set_video_header(s->avctx, VDP_MPEG4_VOL_HEADER);
+            }
         } else if (startcode == USER_DATA_STARTCODE) {
             decode_user_data(ctx, gb);
         } else if (startcode == GOP_STARTCODE) {
@@ -2776,6 +2780,18 @@
     LIBAVUTIL_VERSION_INT,
 };
 
+const enum AVPixelFormat ff_mpeg4_hwaccel_pixfmt_list_420[] = {
+#if CONFIG_VAAPI
+   AV_PIX_FMT_VAAPI_VLD,
+#endif
+#if CONFIG_VDPAU
+//   AV_PIX_FMT_VDPAU_MPEG4,
+   AV_PIX_FMT_VDPAU,
+#endif
+   AV_PIX_FMT_YUV420P,
+   AV_PIX_FMT_NONE
+};
+
 AVCodec ff_mpeg4_decoder = {
     .name                  = "mpeg4",
     .long_name             = NULL_IF_CONFIG_SMALL("MPEG-4 part 2"),
@@ -2785,12 +2801,12 @@
     .init                  = decode_init,
     .close                 = ff_h263_decode_end,
     .decode                = ff_h263_decode_frame,
-    .capabilities          = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1 |
+    .capabilities          = /*AV_CODEC_CAP_DRAW_HORIZ_BAND |*/ AV_CODEC_CAP_DR1 |
                              AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_DELAY |
                              AV_CODEC_CAP_FRAME_THREADS,
     .flush                 = ff_mpeg_flush,
     .max_lowres            = 3,
-    .pix_fmts              = ff_h263_hwaccel_pixfmt_list_420,
+    .pix_fmts              = ff_mpeg4_hwaccel_pixfmt_list_420,
     .profiles              = NULL_IF_CONFIG_SMALL(mpeg4_video_profiles),
     .update_thread_context = ONLY_IF_THREADS_ENABLED(mpeg4_update_thread_context),
     .priv_class = &mpeg4_class,
@@ -2814,10 +2830,12 @@
     .init           = decode_init,
     .close          = ff_h263_decode_end,
     .decode         = ff_h263_decode_frame,
-    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_DELAY |
-                      AV_CODEC_CAP_HWACCEL_VDPAU,
-    .pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_VDPAU_MPEG4,
-                                                  AV_PIX_FMT_NONE },
+    .flush          = ff_mpeg_flush,
+    .capabilities   = CODEC_CAP_DR1 | CODEC_CAP_TRUNCATED | CODEC_CAP_DELAY |
+                      CODEC_CAP_HWACCEL_VDPAU,
+    .pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_VDPAU,
+                                                   AV_PIX_FMT_NONE },
+    .profiles       = NULL_IF_CONFIG_SMALL(mpeg4_video_profiles),
     .priv_class     = &mpeg4_vdpau_class,
 };
 #endif
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/msmpeg4dec.c FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/msmpeg4dec.c
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/msmpeg4dec.c	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/msmpeg4dec.c	2016-02-09 20:27:54.416712690 +0100
@@ -915,6 +915,18 @@
     return 0;
 }
 
+const enum AVPixelFormat ff_msmpeg_hwaccel_pixfmt_list_420[] = {
+#if CONFIG_VAAPI
+    AV_PIX_FMT_VAAPI_VLD,
+#endif
+#if CONFIG_VDPAU
+//    AV_PIX_FMT_VDPAU_MSMPEG4V3,
+    AV_PIX_FMT_VDPAU,
+#endif
+    AV_PIX_FMT_YUV420P,
+    AV_PIX_FMT_NONE
+};
+
 AVCodec ff_msmpeg4v1_decoder = {
     .name           = "msmpeg4v1",
     .long_name      = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 1"),
@@ -924,12 +936,9 @@
     .init           = ff_msmpeg4_decode_init,
     .close          = ff_h263_decode_end,
     .decode         = ff_h263_decode_frame,
-    .capabilities   = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1,
+    .capabilities   = /* CODEC_CAP_DRAW_HORIZ_BAND | */ AV_CODEC_CAP_DR1 | AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_DELAY,
     .max_lowres     = 3,
-    .pix_fmts       = (const enum AVPixelFormat[]) {
-        AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_NONE
-    },
+    .pix_fmts       = ff_msmpeg_hwaccel_pixfmt_list_420,
 };
 
 AVCodec ff_msmpeg4v2_decoder = {
@@ -941,12 +950,9 @@
     .init           = ff_msmpeg4_decode_init,
     .close          = ff_h263_decode_end,
     .decode         = ff_h263_decode_frame,
-    .capabilities   = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1,
+    .capabilities   = /* CODEC_CAP_DRAW_HORIZ_BAND | */ AV_CODEC_CAP_DR1 | AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_DELAY,
     .max_lowres     = 3,
-    .pix_fmts       = (const enum AVPixelFormat[]) {
-        AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_NONE
-    },
+    .pix_fmts       = ff_msmpeg_hwaccel_pixfmt_list_420,
 };
 
 AVCodec ff_msmpeg4v3_decoder = {
@@ -958,12 +964,9 @@
     .init           = ff_msmpeg4_decode_init,
     .close          = ff_h263_decode_end,
     .decode         = ff_h263_decode_frame,
-    .capabilities   = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1,
+    .capabilities   = /* CODEC_CAP_DRAW_HORIZ_BAND | */ AV_CODEC_CAP_DR1 | AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_DELAY,
     .max_lowres     = 3,
-    .pix_fmts       = (const enum AVPixelFormat[]) {
-        AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_NONE
-    },
+    .pix_fmts       = ff_msmpeg_hwaccel_pixfmt_list_420,
 };
 
 AVCodec ff_wmv1_decoder = {
@@ -975,10 +978,69 @@
     .init           = ff_msmpeg4_decode_init,
     .close          = ff_h263_decode_end,
     .decode         = ff_h263_decode_frame,
-    .capabilities   = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1,
+    .capabilities   = /* CODEC_CAP_DRAW_HORIZ_BAND | */ AV_CODEC_CAP_DR1 | AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_DELAY,
+    .max_lowres     = 3,
+    .pix_fmts       = ff_msmpeg_hwaccel_pixfmt_list_420,
+};
+
+#define CONFIG_MSMPEGV3_VDPAU_DECODER 1
+#if CONFIG_MSMPEGV3_VDPAU_DECODER
+static const AVOption msmpeg_options[] = {
+    {"quarter_sample", "1/4 subpel MC", offsetof(MpegEncContext, quarter_sample), FF_OPT_TYPE_INT, {.i64 = 0}, 0, 1, 0},
+    {"divx_packed", "divx style packed b frames", offsetof(MpegEncContext, divx_packed), FF_OPT_TYPE_INT, {.i64 = 0}, 0, 1, 0},
+    {NULL}
+};
+
+static const AVClass msmpegv1_vdpau_class = {
+    "MSMPEG4 Video VDPAU Decoder",
+    av_default_item_name,
+    msmpeg_options,
+    LIBAVUTIL_VERSION_INT,
+};
+ 
+AVCodec ff_msmpeg4v3_vdpau_decoder = {
+    .name           = "msmpeg4_vdpau",
+    .long_name      = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 3 (VDPAU)"),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_MSMPEG4V3,
+    .priv_data_size = sizeof(Mpeg4DecContext),
+    .init           = ff_msmpeg4_decode_init,
+    .close          = ff_h263_decode_end,
+    .decode         = ff_h263_decode_frame,
+    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_HWACCEL_VDPAU,
+    .max_lowres     = 3,
+    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU, AV_PIX_FMT_NONE },
+    .priv_class     = &msmpegv1_vdpau_class,
+};
+
+AVCodec ff_msmpeg4v2_vdpau_decoder = {
+    .name           = "msmpeg4v2_vdpau",
+    .long_name      = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 2 (VDPAU)"),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_MSMPEG4V2,
+    .priv_data_size = sizeof(Mpeg4DecContext),
+    .init           = ff_msmpeg4_decode_init,
+    .close          = ff_h263_decode_end,
+    .decode         = ff_h263_decode_frame,
+    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_HWACCEL_VDPAU,
     .max_lowres     = 3,
-    .pix_fmts       = (const enum AVPixelFormat[]) {
-        AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_NONE
-    },
+    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU, AV_PIX_FMT_NONE },
+    .priv_class     = &msmpegv1_vdpau_class,
 };
+
+AVCodec ff_msmpeg4v1_vdpau_decoder = {
+    .name           = "msmpeg4v1_vdpau",
+    .long_name      = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 1 (VDPAU)"),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_MSMPEG4V1,
+    .priv_data_size = sizeof(Mpeg4DecContext),
+    .init           = ff_msmpeg4_decode_init,
+    .close          = ff_h263_decode_end,
+    .decode         = ff_h263_decode_frame,
+    .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_TRUNCATED | AV_CODEC_CAP_HWACCEL_VDPAU,
+    .max_lowres     = 3,
+    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU, AV_PIX_FMT_NONE },
+    .priv_class     = &msmpegv1_vdpau_class,
+};
+
+#endif
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/old_codec_ids.h FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/old_codec_ids.h
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/old_codec_ids.h	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/old_codec_ids.h	2016-02-09 20:23:03.576004012 +0100
@@ -49,6 +49,7 @@
     CODEC_ID_MSMPEG4V1,
     CODEC_ID_MSMPEG4V2,
     CODEC_ID_MSMPEG4V3,
+    CODEC_ID_MSMPEG4V4,
     CODEC_ID_WMV1,
     CODEC_ID_WMV2,
     CODEC_ID_H263P,
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/utils.c FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/utils.c
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/utils.c	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/utils.c	2016-02-09 20:23:03.579337240 +0100
@@ -1152,8 +1152,8 @@
 
 enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
 {
-    while (*fmt != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt(*fmt))
-        ++fmt;
+//    while (*fmt != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt(*fmt))
+//         ++fmt;
     return fmt[0];
 }
 
@@ -2447,6 +2447,7 @@
             ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                        &tmp);
             picture->pkt_dts = avpkt->dts;
+            //picture->pts = avpkt->pts;
 
             if(!avctx->has_b_frames){
                 av_frame_set_pkt_pos(picture, avpkt->pos);
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/vc1dec.c FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/vc1dec.c
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/vc1dec.c	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/vc1dec.c	2016-02-09 20:23:03.579337240 +0100
@@ -1171,7 +1171,7 @@
     .close          = ff_vc1_decode_end,
     .decode         = vc1_decode_frame,
     .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HWACCEL_VDPAU,
-    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU_WMV3, AV_PIX_FMT_NONE },
+    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU, AV_PIX_FMT_NONE },
     .profiles       = NULL_IF_CONFIG_SMALL(profiles)
 };
 #endif
@@ -1187,7 +1187,7 @@
     .close          = ff_vc1_decode_end,
     .decode         = vc1_decode_frame,
     .capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HWACCEL_VDPAU,
-    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU_VC1, AV_PIX_FMT_NONE },
+    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_VDPAU, AV_PIX_FMT_NONE },
     .profiles       = NULL_IF_CONFIG_SMALL(profiles)
 };
 #endif
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/vdpau.c FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/vdpau.c
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/vdpau.c	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/vdpau.c	2016-02-09 20:23:03.579337240 +0100
@@ -676,9 +676,11 @@
 
     switch (s->pict_type) {
     case AV_PICTURE_TYPE_B:
+    case AV_PICTURE_TYPE_S:
         next = (struct vdpau_render_state *)s->next_picture.f->data[0];
         assert(next);
         render->info.mpeg4.backward_reference     = next->surface;
+        if( s->pict_type != AV_PICTURE_TYPE_S)
         render->info.mpeg4.vop_coding_type        = 2;
         // no break here, going to set forward prediction
     case AV_PICTURE_TYPE_P:
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/vdpau.h FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/vdpau.h
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/vdpau.h	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/vdpau.h	2016-02-09 20:23:03.579337240 +0100
@@ -101,6 +101,7 @@
      * Set by the user.
      */
     VdpDecoderRender *render;
+    VdpDecoderSetControlData *set_video_header;
 
 #if FF_API_BUFS_VDPAU
     /**
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/vdpau_internal.h FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/vdpau_internal.h
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/vdpau_internal.h	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/vdpau_internal.h	2016-02-09 20:23:03.579337240 +0100
@@ -123,6 +123,8 @@
 int ff_vdpau_common_end_frame(AVCodecContext *avctx, AVFrame *frame,
                               struct vdpau_picture_context *pic);
 int ff_vdpau_mpeg_end_frame(AVCodecContext *avctx);
+int ff_vdpau_msmpeg_end_frame(AVCodecContext *avctx);
+
 int ff_vdpau_add_buffer(struct vdpau_picture_context *pic, const uint8_t *buf,
                         uint32_t buf_size);
 
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/vdpau_mpeg4.c FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/vdpau_mpeg4.c
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/vdpau_mpeg4.c	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/vdpau_mpeg4.c	2016-02-09 20:23:03.579337240 +0100
@@ -28,6 +28,8 @@
 #include "vdpau.h"
 #include "vdpau_internal.h"
 
+int vdpau_mpeg4_create_video_headers(AVCodecContext *avctx, uint32_t id, VdpDecoderControlData *data);
+
 static int vdpau_mpeg4_start_frame(AVCodecContext *avctx,
                                    const uint8_t *buffer, uint32_t size)
 {
@@ -46,9 +48,11 @@
 
     switch (s->pict_type) {
     case AV_PICTURE_TYPE_B:
+    case AV_PICTURE_TYPE_S:
         ref = ff_vdpau_get_surface_id(s->next_picture.f);
         assert(ref != VDP_INVALID_HANDLE);
         info->backward_reference = ref;
+        if( s->pict_type != AV_PICTURE_TYPE_S)
         info->vop_coding_type    = 2;
         /* fall-through */
     case AV_PICTURE_TYPE_P:
@@ -88,6 +92,65 @@
      return 0;
 }
 
+int vdpau_mpeg4_create_video_headers(AVCodecContext *avctx, uint32_t id, VdpDecoderControlData *data)
+{
+   Mpeg4DecContext * const s = avctx->priv_data;
+   memset(data, 0x0, sizeof(*data));
+    
+   if(id == VDP_MPEG4_VOL_HEADER) 
+   {
+      VdpDecoderMpeg4VolHeader *vol = &(data->mpeg4VolHdr);
+        
+      vol->struct_version               = VDP_MPEG4_STRUCT_VERSION;
+      vol->video_object_type_indication = s->m.vo_type;
+      vol->aspect_ratio_info            = s->m.aspect_ratio_info;
+      vol->par_width                    = s->m.avctx->sample_aspect_ratio.num;
+      vol->par_height                   = s->m.avctx->sample_aspect_ratio.den;
+      vol->vol_control_parameters       = s->vol_control_parameters;
+      vol->low_delay                    = s->m.low_delay;
+      vol->video_object_layer_shape     = s->shape;
+      vol->vop_time_increment_resolution = s->m.avctx->time_base.den;
+      vol->video_object_layer_width     = s->m.width;
+      vol->video_object_layer_height    = s->m.height;
+      vol->interlaced                   = s->m.progressive_frame ^ 1;
+      vol->sprite_enable                = s->vol_sprite_usage;
+      vol->no_of_sprite_warping_points  = s->num_sprite_warping_points;
+      vol->sprite_warping_accuracy      = s->m.sprite_warping_accuracy;
+      vol->sprite_brightness_change     = s->sprite_brightness_change;
+      vol->quant_precision              = s->m.quant_precision;
+      vol->quant_type                   = s->m.mpeg_quant;
+      for(int i=0; i < 64; ++i)
+      {
+            //to be done matrices
+      }
+      vol->quarter_sample               = s->m.quarter_sample;
+      vol->resync_marker_disable        = s->resync_marker;
+      vol->data_partitioned             = s->m.data_partitioning;
+      vol->reversible_vlc               = s->rvlc;
+      vol->newpred_enable               = s->new_pred;
+      vol->scalability                  = s->scalability;
+      vol->enhancement_type             = s->enhancement_type;
+
+      return 1;
+   }
+   return 0;
+}
+
+static int vdpau_mpeg4_set_video_header (AVCodecContext *avctx, uint32_t id)
+{
+    AVVDPAUContext *hwctx = avctx->hwaccel_context;
+    VdpDecoderControlData data;
+
+    if(!hwctx->set_video_header)
+       return 0;
+
+    if(vdpau_mpeg4_create_video_headers(avctx, id, &data))
+       return hwctx->set_video_header(hwctx->decoder, id, &data);
+
+    return 0;
+}
+
+
 #if CONFIG_H263_VDPAU_HWACCEL
 static int vdpau_h263_init(AVCodecContext *avctx)
 {
@@ -103,6 +166,7 @@
     .start_frame    = vdpau_mpeg4_start_frame,
     .end_frame      = ff_vdpau_mpeg_end_frame,
     .decode_slice   = vdpau_mpeg4_decode_slice,
+//    .set_video_header = vdpau_mpeg4_set_video_header
     .frame_priv_data_size = sizeof(struct vdpau_picture_context),
     .init           = vdpau_h263_init,
     .uninit         = ff_vdpau_common_uninit,
@@ -140,6 +204,7 @@
     .start_frame    = vdpau_mpeg4_start_frame,
     .end_frame      = ff_vdpau_mpeg_end_frame,
     .decode_slice   = vdpau_mpeg4_decode_slice,
+//    .set_video_header = vdpau_mpeg4_set_video_header
     .frame_priv_data_size = sizeof(struct vdpau_picture_context),
     .init           = vdpau_mpeg4_init,
     .uninit         = ff_vdpau_common_uninit,
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavcodec/vdpau_msmpeg4.c FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/vdpau_msmpeg4.c
--- FFmpeg-2.8.5-Jarvis-rc1/libavcodec/vdpau_msmpeg4.c	1970-01-01 01:00:00.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavcodec/vdpau_msmpeg4.c	2016-02-09 20:23:03.579337240 +0100
@@ -0,0 +1,146 @@
+/*
+ * MPEG-4 Part 2 / H.263 decode acceleration through VDPAU
+ *
+ * Copyright (c) 2008 NVIDIA
+ * Copyright (c) 2013 Rémi Denis-Courmont
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <vdpau/vdpau.h>
+
+#include "avcodec.h"
+#include "mpeg4video.h"
+#include "vdpau.h"
+#include "vdpau_internal.h"
+
+static int vdpau_msmpeg4_start_frame(AVCodecContext *avctx,
+                                   const uint8_t *buffer, uint32_t size)
+{
+   Mpeg4DecContext *ctx = avctx->priv_data;
+   MpegEncContext * const s = &ctx->m;
+   Picture *pic             = s->current_picture_ptr;
+   struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;
+   VdpPictureInfoMPEG4Part2 *info = &pic_ctx->info.mpeg4;
+   VdpVideoSurface ref;
+   int i;
+
+   /* fill VdpPictureInfoMPEG4Part2 struct */
+   info->forward_reference  = VDP_INVALID_HANDLE;
+   info->backward_reference = VDP_INVALID_HANDLE;
+   info->vop_coding_type    = 0;
+
+   switch (s->pict_type) {
+      case AV_PICTURE_TYPE_B:
+      case AV_PICTURE_TYPE_S:
+         ref = ff_vdpau_get_surface_id(s->next_picture.f);
+         assert(ref != VDP_INVALID_HANDLE);
+         info->backward_reference = ref;
+         if( s->pict_type != AV_PICTURE_TYPE_S)
+            info->vop_coding_type    = 2;
+         /* fall-through */
+      case AV_PICTURE_TYPE_P:
+         ref = ff_vdpau_get_surface_id(s->last_picture.f);
+         assert(ref != VDP_INVALID_HANDLE);
+         info->forward_reference  = ref;
+   }
+
+   info->trd[0]                            = s->pp_time;
+   info->trb[0]                            = s->pb_time;
+   info->trd[1]                            = s->pp_field_time >> 1;
+   info->trb[1]                            = s->pb_field_time >> 1;
+   info->vop_time_increment_resolution     = s->avctx->time_base.den;
+   info->vop_fcode_forward                 = s->f_code;
+   info->vop_fcode_backward                = s->b_code;
+   info->resync_marker_disable             = !ctx->resync_marker;
+   info->interlaced                        = !s->progressive_sequence;
+   info->quant_type                        = s->mpeg_quant;
+   info->quarter_sample                    = s->quarter_sample;
+   info->short_video_header                = avctx->codec->id == AV_CODEC_ID_H263;
+   info->rounding_control                  = s->no_rounding;
+   info->alternate_vertical_scan_flag      = s->alternate_scan;
+   info->top_field_first                   = s->top_field_first;
+   for (i = 0; i < 64; ++i) {
+      info->intra_quantizer_matrix[i]     = s->intra_matrix[i];
+      info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];
+   }
+
+   ff_vdpau_common_start_frame(pic_ctx, buffer, size);
+   return ff_vdpau_add_buffer(pic_ctx, buffer, size);
+}
+
+static int vdpau_mpeg4_decode_slice(av_unused AVCodecContext *avctx,
+                                    av_unused const uint8_t *buffer,
+                                    av_unused uint32_t size)
+{
+     return 0;
+}
+static int vdpau_msmpeg4_set_video_header (AVCodecContext *avctx, uint32_t id, VdpDecoderControlData *data)
+{
+   Mpeg4DecContext * const s = avctx->priv_data;
+   memset(data, 0x0, sizeof(*data));
+    
+   if(id == VDP_MPEG4_VOL_HEADER) 
+   {
+      VdpDecoderMpeg4VolHeader *vol = &(data->mpeg4VolHdr);
+        
+      vol->struct_version               = VDP_MPEG4_STRUCT_VERSION;
+      vol->video_object_type_indication = s->m.vo_type;
+      vol->aspect_ratio_info            = s->m.aspect_ratio_info;
+      vol->par_width                    = s->m.avctx->sample_aspect_ratio.num;
+      vol->par_height                   = s->m.avctx->sample_aspect_ratio.den;
+      vol->vol_control_parameters       = s->vol_control_parameters;
+      vol->low_delay                    = s->m.low_delay;
+      vol->video_object_layer_shape     = s->shape;
+      vol->vop_time_increment_resolution = s->m.avctx->time_base.den;
+      vol->video_object_layer_width     = s->m.width;
+      vol->video_object_layer_height    = s->m.height;
+      vol->interlaced                   = s->m.progressive_frame ^ 1;
+      vol->sprite_enable                = s->vol_sprite_usage;
+      vol->no_of_sprite_warping_points  = s->num_sprite_warping_points;
+      vol->sprite_warping_accuracy      = s->m.sprite_warping_accuracy;
+      vol->sprite_brightness_change     = s->sprite_brightness_change;
+      vol->quant_precision              = s->m.quant_precision;
+      vol->quant_type                   = s->m.mpeg_quant;
+      for(int i=0; i < 64; ++i)
+      {
+            //to be done matrices
+      }
+      vol->quarter_sample               = s->m.quarter_sample;
+      vol->resync_marker_disable        = s->resync_marker;
+      vol->data_partitioned             = s->m.data_partitioning;
+      vol->reversible_vlc               = s->rvlc;
+      vol->newpred_enable               = s->new_pred;
+      vol->scalability                  = s->scalability;
+      vol->enhancement_type             = s->enhancement_type;
+
+      return 1;
+    }
+    return 0;
+}
+
+AVHWAccel ff_msmpeg4v3_vdpau_hwaccel = {
+    .name           = "msmpeg4v3_vdpau",
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_MSMPEG4V3,
+    .pix_fmt        = AV_PIX_FMT_VDPAU,
+    .start_frame    = vdpau_msmpeg4_start_frame,
+    .end_frame      = ff_vdpau_mpeg_end_frame,
+    .decode_slice   = vdpau_mpeg4_decode_slice,
+//    .set_video_header = vdpau_msmpeg4_set_video_header,
+};
+
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavformat/mov.c FFmpeg-2.8.5-Jarvis-rc1.new/libavformat/mov.c
--- FFmpeg-2.8.5-Jarvis-rc1/libavformat/mov.c	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavformat/mov.c	2016-02-09 20:23:03.582670468 +0100
@@ -3037,6 +3037,7 @@
             return ret;
     }
 
+#if 0
     switch (st->codec->codec_id) {
 #if CONFIG_H261_DECODER
     case AV_CODEC_ID_H261:
@@ -3051,6 +3052,7 @@
         st->codec->height= 0;
         break;
     }
+#endif
 
     /* Do not need those anymore. */
     av_freep(&sc->chunk_offsets);
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavutil/arm/intmath.h FFmpeg-2.8.5-Jarvis-rc1.new/libavutil/arm/intmath.h
--- FFmpeg-2.8.5-Jarvis-rc1/libavutil/arm/intmath.h	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavutil/arm/intmath.h	2016-02-09 20:23:03.582670468 +0100
@@ -69,7 +69,7 @@
     __asm__ ("ssat %0, %2, %1" : "=r"(x) : "r"(a), "i"(p+1));
     return x;
 }
-
+/*
 #define av_clip_uintp2 av_clip_uintp2_arm
 static av_always_inline av_const unsigned av_clip_uintp2_arm(int a, int p)
 {
@@ -77,6 +77,7 @@
     __asm__ ("usat %0, %2, %1" : "=r"(x) : "r"(a), "i"(p));
     return x;
 }
+*/
 
 #define av_sat_add32 av_sat_add32_arm
 static av_always_inline int av_sat_add32_arm(int a, int b)
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavutil/pixdesc.c FFmpeg-2.8.5-Jarvis-rc1.new/libavutil/pixdesc.c
--- FFmpeg-2.8.5-Jarvis-rc1/libavutil/pixdesc.c	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavutil/pixdesc.c	2016-02-09 20:23:03.582670468 +0100
@@ -963,6 +963,30 @@
         .log2_chroma_h = 1,
         .flags = AV_PIX_FMT_FLAG_HWACCEL,
     },
+    [AV_PIX_FMT_VDPAU_MSMPEG4V1] = {
+        .name = "vdpau_msmpegv1",
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = AV_PIX_FMT_FLAG_HWACCEL,
+    },
+    [AV_PIX_FMT_VDPAU_MSMPEG4V2] = {
+        .name = "vdpau_msmpegv2",
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = AV_PIX_FMT_FLAG_HWACCEL,
+    },
+    [AV_PIX_FMT_VDPAU_MSMPEG4V3] = {
+        .name = "vdpau_msmpegv3",
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = AV_PIX_FMT_FLAG_HWACCEL,
+    },
+    [AV_PIX_FMT_VDPAU_MSMPEG4V4] = {
+        .name = "vdpau_msmpegv4",
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = AV_PIX_FMT_FLAG_HWACCEL,
+    },
 #endif
     [AV_PIX_FMT_RGB48BE] = {
         .name = "rgb48be",
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavutil/pixfmt.h FFmpeg-2.8.5-Jarvis-rc1.new/libavutil/pixfmt.h
--- FFmpeg-2.8.5-Jarvis-rc1/libavutil/pixfmt.h	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavutil/pixfmt.h	2016-02-09 20:23:03.582670468 +0100
@@ -107,6 +107,10 @@
     AV_PIX_FMT_VDPAU_MPEG2,///< MPEG-2 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
     AV_PIX_FMT_VDPAU_WMV3,///< WMV3 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
     AV_PIX_FMT_VDPAU_VC1, ///< VC-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
+    AV_PIX_FMT_VDPAU_MSMPEG4V1,
+    AV_PIX_FMT_VDPAU_MSMPEG4V2,
+    AV_PIX_FMT_VDPAU_MSMPEG4V3,
+    AV_PIX_FMT_VDPAU_MSMPEG4V4,
 #endif
     AV_PIX_FMT_RGB48BE,   ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian
     AV_PIX_FMT_RGB48LE,   ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian
diff -rNu FFmpeg-2.8.5-Jarvis-rc1/libavutil/utils.c FFmpeg-2.8.5-Jarvis-rc1.new/libavutil/utils.c
--- FFmpeg-2.8.5-Jarvis-rc1/libavutil/utils.c	2016-01-15 18:25:16.000000000 +0100
+++ FFmpeg-2.8.5-Jarvis-rc1.new/libavutil/utils.c	2016-02-09 20:23:03.582670468 +0100
@@ -42,7 +42,7 @@
         return LIBAVUTIL_VERSION_INT;
 
 #if FF_API_VDPAU
-    av_assert0(AV_PIX_FMT_VDA_VLD == 81); //check if the pix fmt enum has not had anything inserted or removed by mistake
+//    av_assert0(AV_PIX_FMT_VDA_VLD == 81); //check if the pix fmt enum has not had anything inserted or removed by mistake
 #endif
     av_assert0(AV_SAMPLE_FMT_DBLP == 9);
     av_assert0(AVMEDIA_TYPE_ATTACHMENT == 4);
